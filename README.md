# stm32_uart_modbus
基于stm32的uart串口modbus通讯协议
# modbus-RTU协议
Modbus报文帧结构
一个报文就是一帧数据，一个数据帧就一个报文： 指的是一串完整的指令数据，本质就是一串数据
Modbus协议在串行链路上的报文格式如下所示：
![image](https://github.com/KeyL-SJ/stm32_uart_modbus/assets/78483846/bcec2fe4-3a28-42b3-b2aa-8d75f8fe1f36)
![image](https://github.com/KeyL-SJ/stm32_uart_modbus/assets/78483846/08571b8d-8013-4afb-9fe5-393f01fab22f)
从机地址: 每个从机都有唯一地址，占用一个字节,范围0-255,其中有效范围是1-247,其中255是广播地址(广播就是对所有从机发送应答)

#### 功能码: 占用一个字节,功能码的意义就是,知道这个指令是干啥的,比如你可以查询从机的数据,也可以修改从机的数据,所以不同功能码对应不同功能.
#### 数据: 根据功能码不同,有不同功能，比方说功能码是查询从机的数据，这里就是查询数据的地址和查询字节数等。
#### 校验: 在数据传输过程中可能数据会发生错误，CRC检验检测接收的数据是否正确
# Modbus功能码
# Modbus规定了多个功能，那么为了方便的使用这些功能，我们给每个功能都设定一个功能码，也就是指代码。
Modbus协议同时规定了二十几种功能码，但是常用的只有8种，用于对存储区的读写，如下表所示：
![image](https://github.com/KeyL-SJ/stm32_uart_modbus/assets/78483846/5f6a0848-b9b6-4fac-8ccb-8aa1ed3e53f4)
当然我们用的最多的就是03和06 一个是读取数据，一个是修改数据。

# CRC校验
# 错误校验（CRC）域占用两个字节包含了一个16位的二进制值。CRC值由传输设备计算出来，然后附加到数据帧上，接收设备在接收数据时重新计算CRC值，然后与接收到的CRC域中的值进行比较，如果这两个值不相等，就发生了错误。
例如若主机向从机发送报文01 03 00 00 00 01 84 0A 其中， 最后两个字节84 0A就是CRC校验位，从机接收到主机发送的报文之后，根据报文的非校验位01 03 00 00 00 01计算CRC校验位，若从机计算出的校验位与主机发送的校验位相同，则证明数据在发送的过程中没有发生错误，反之，则代表数据传输发生错误。
